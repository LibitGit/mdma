use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

/// Recursively collects all file paths from a `src` directory
fn collect_src_files(base_dir: &Path, file_names: &mut Vec<String>) -> io::Result<()> {
    for entry in fs::read_dir(base_dir)? {
        let entry = entry?;
        let path = entry.path();
        if path.is_dir() {
            // Check if this directory has a `src` subdirectory
            let src_path = path.join("src");
            if src_path.exists() && src_path.is_dir() {
                collect_files_from_src(&src_path, file_names)?;
            } else {
                // Recurse into other directories
                collect_src_files(&path, file_names)?;
            }
        }
    }
    Ok(())
}

/// Collects .rs files from a src directory
fn collect_files_from_src(src_dir: &Path, file_names: &mut Vec<String>) -> io::Result<()> {
    for entry in fs::read_dir(src_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            // Recursively handle subdirectories
            collect_files_from_src(&path, file_names)?;
        } else if let Some(file_str) = path.to_str() {
            // Only collect .rs files
            if file_str.ends_with(".rs") {
                // Find the index after "src\\" or "src/"
                if let Some(sliced_path) = file_str
                    .find("extension-workspace\\")
                    .or_else(|| file_str.find("extension-workspace/"))
                    .map(|idx| &file_str[idx + 24..])
                {
                    //println!("{} => {sliced_path}", file_str);

                    file_names.push(sliced_path.to_string());
                }
            }
        }
    }

    Ok(())
}

fn decode_location(encoded: u32) -> (u16, u16) {
    let high = (encoded >> 16) as u16; // Extract the high 16 bits
    let low = (encoded & 0xFFFF) as u16; // Extract the low 16 bits
    (high, low)
}

fn main() -> io::Result<()> {
    // Move to the parent directory of the current working directory
    let current_dir = env::current_dir()?;
    let parent_dir = current_dir.parent().expect("No parent directory found");
    let mut file_names = Vec::new();

    // Collect all `.rs` files from `src` directories under the parent directory
    collect_src_files(parent_dir, &mut file_names)?;

    if let Some(arg) = env::args().nth(1) {
        let arg = arg.parse().unwrap();
        let (file_idx, line) = decode_location(arg);
        println!(
            "{arg} => {}:{line} (idx: {})",
            file_names[file_idx as usize], file_idx
        );

        return Ok(());
    }

    // Create the full path
    let file_path = parent_dir.join("extension-workspace\\src\\common\\src\\file_names.rs");

    // Create the file
    let mut output_file = File::create(file_path)?;

    writeln!(
        output_file,
        r#"// This file is generated by generate_file_names.rs
// Do not edit manually.

use obfstr::obfstr as s;
use wasm_bindgen::intern as i;

///Retrieves hashed file name index
///
///If the pkg_name is not trackable from caller (for instance when using `.unwrap_js`)
///and the caller file is a lib.rs uses the first lib.rs from partial file paths.
///
///When this happens find the error with only the line number.
pub fn find_file_index(pkg_name: Option<&str>, file: &str) -> Option<u16> {{
    //Partial file paths:"#
    )?;

    for (index, file) in file_names.iter().enumerate() {
        let lint = match index {
            index if index < 10 => "  ",
            index if index < 100 => " ",
            _ => "",
        };
        writeln!(output_file, r#"    // {index}{lint} => {file}"#)?;
    }

    writeln!(output_file, "    [")?;
    for file in file_names {
        // Write file name as a string literal
        writeln!(output_file, r#"        i(s!({file:?})),"#)?;
    }

    writeln!(
        output_file,
        r#"    ]
    .iter()
    .enumerate()
    .find(|(_, partial_file_path)| {{
        file.ends_with(*partial_file_path)
            && match pkg_name {{
                Some(pkg_name) => partial_file_path.contains(pkg_name),
                None => true,
            }}
    }})
    .map(|(index, _)| index as u16)
}}
"#
    )?;

    println!("Generated file names in `file_names.rs`");
    Ok(())
}
